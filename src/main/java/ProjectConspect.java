
public class ProjectConspect {
	
//@GetMapping
	
//	Эта аннотация служит для маппинга запросов на классы-контроллеры и методы.
//	Раньше ее использовали для методов класса, чтобы указать URI, http-метод,
//	тип отправляемых данных, и т.п. В более новых версиях Spring ее заменили на аннотации
//	@GetMapping, @PostMapping, и т.п.

//@ResponseStatus
	
//201 - это код состояния HTTP. Это указывает на то, что
//
//запрос был выполнен и привел к созданию нового ресурса.
//
//
//Поэтому, если ваш сервер возвращает такой код состояния, клиент понимает, 
//что был создан некоторый (концептуальный) ресурс. Каков этот ресурс - 
//это ваша ответственность, вы сервер.
//
//Код состояния является частью строки состояния ответа HTTP.

//@PathVariable            
//заключается в получении некоторого заполнителя из uri (Spring называть его шаблоном URI) 
//- см. Spring Справочная информация Глава 16.3.2.2 Шаблоны шаблонов URI
//@RequestParam - получить параметр - 
//см. Spring Ссылка Chapter 16.3.3.3 
//Параметры запроса привязки к параметрам метода с помощью @RequestParam
//Если URL http://localhost:8080/MyApp/user/1234/invoices?date=12-05-2013 получает 
//счета-фактуры для пользователя 1234 5 декабря 2013 года, метод контроллера будет выглядеть так:
//
//@RequestMapping(value="/user/{userId}/invoices", method = RequestMethod.GET)
//public List<Invoice> listUsersInvoices(
//            @PathVariable("userId") int user,
//            @RequestParam(value = "date", required = false) Date dateOrNull) {
//  ...
//}
//Кроме того, параметры запроса могут быть необязательными, но переменные пути не могут - если бы они были,
//это изменило бы иерархию путей URL-адресов и представило бы конфликты сопоставления запросов.


//@PostMapping
//Сопоставить запрос POST
//
//Новые возможности Spring MVC
//обеспечивает поддержку стиля Restful.
//
//@GetMapping, обработать запрос на получение
//@PostMapping, обработать почтовый запрос
//@PutMapping, обработать запрос на размещение
//@DeleteMapping, обработать запрос на удаление

//@Valid   
//Достаточно добавить в параметр input аннотацию @Valid, чтобы сообщить спрингу передать объект Валидатору,
//прежде чем делать с ним что-либо еще.
//
//
//Если класс содержит поле с другим классом, который тоже необходимо проверить — 
//это поле необходимо пометить аннотацией Valid.
//
//
//Исключение MethodArgumentNotValidException выбрасывается, когда объект не проходит проверку.
//По умолчанию, Spring переведет это исключение в HTTP статус 400.

//Объект Customer - DTO.

//DTO объект - объект, который не содержит методы.
//Он может содержать только поля, геттеры/сеттеры, и конструкторы.
//
//Data Transfer Object - объект, передающий данные. Данные - это и есть поля в классе.
//
//Реальный пример - игра шашки. У вас должен быть объект Checker(шашка). 
//У него не должно быть методов, только поля.
//

//Что представляет собой объект DATA ACCESS OBJECT (DAO) -

//Это объект/интерфейс, который используется для доступа к данным из базы данных хранения данных.
//
//ПОЧЕМУ ИСПОЛЬЗУЕМ DAO:
//  
//он абстрагирует извлечение данных из ресурса данных, например базы данных. 
//Концепция "отделяет клиентский интерфейс ресурса данных от механизма доступа к данным.
//
//Проблема с непосредственным доступом к данным заключается в том, что источник данных может измениться. 
//Рассмотрим, например, что ваше приложение развернуто в среде, которая обращается к базе данных Oracle. 
//Затем он будет развернут в среде, использующей Microsoft SQL Server.
//Если ваше приложение использует хранимые процедуры и код базы данных 
//(например, генерирует последовательность номеров), как вы справляетесь с этим в своем приложении? 
//У вас есть два варианта:
//
//Перепишите ваше приложение для использования SQL Server вместо Oracle (
//или добавьте условный код для обработки различий) или
//Создайте слой между логикой приложения и доступом к данным.
//
//Его все называют DAO Pattern, он состоит из следующих элементов:
//
//Интерфейс объектов доступа к данным. Этот интерфейс определяет стандартные операции, 
//которые должны выполняться на объектах модели.
//Конкретный класс объекта доступа к данным. Этот класс реализует интерфейс выше. 
//Этот класс отвечает за получение данных из источника данных, который может быть
//базой данных /xml или любым другим механизмом хранения.
//Объект объекта или объекта модели. Этот объект является простым POJO, 
//содержащим методы get/set для хранения данных, полученных с использованием класса DAO.
//
                        
//Аннотация @Controller
//@Controller - это специализация универсальной стереотипной @Component , 
//которая позволяет распознавать класс как управляемый Spring компонент.
//
//@Controller расширяет возможности использования @Component и 
//отмечает аннотированный класс как бизнес-уровень или уровень представления. 
//Когда запрос сделан, это проинформирует DispatcherServlet о включении класса контроллера 
//в сканирование методов, отображаемых аннотацией @RequestMapping
//
//Теперь мы объявим фактический контроллер для определения бизнес-логики и обработки всех запросов,
//связанных с Tree модели.

//@Autowired 
//используется для автоматического внедрения зависимостей указанного типа в текущий bean-компонент. 
//В этом случае TreeRepository компонент TreeRepository вводится как зависимость от TreeController .

//@GetMapping - 
//это ярлык для @RequestMapping(method = RequestMethod.GET) , 
//который используется для сопоставления GET с сопоставленными методами контроллера.

//Мы применили @ResponseBody к уровню класса этого контроллера. 
//Когда обработчики запросов возвращают данные обратно, например return repository.findById() ,
//ответ будет сериализован в JSON перед возвратом клиенту


//Аннотация @RestController

//@RestController в Spring по сути представляют собой просто комбинацию @Controller и @ResponseBody .
//Эта аннотация была добавлена в Spring 4.0, чтобы удалить избыточность объявления @ResponseBody 
//в вашем контроллере.

//Это на одну аннотацию меньше! Если вы также посмотрите на определение интерфейса двух аннотаций,
//чтобы увидеть разницу между ними:

// @Target(ElementType.TYPE) 
// @Retention(RetentionPolicy.RUNTIME) 
// @Documented 
// @Controller 
// @ResponseBody 
// public @interface RestController { 
// //.. 
// } 
// 
// @Target({ElementType.TYPE}) 
// @Retention(RetentionPolicy.RUNTIME) 
// @Documented 
// @Component 
// public @interface Controller { 
// //.. 
// } 
// Интерфейс RestController аннотируется @Controller и @ResponseBody вместо того, 
//чтобы напрямую аннотировать его с помощью @Component .

//Если мы заменим аннотацию нашего контроллера на @RestController , 
//нам не нужно будет изменять домен и уровень сохраняемости, 
//поскольку они все равно будут совместимы с этой аннотацией.
   
//@Validated
//Как указано выше, указывать группы проверки можно только с помощью аннотации @Validated на уровне класса.
//Однако это не очень удобно, поскольку иногда у вас есть класс, содержащий несколько методов с одной 
//и той же сущностью в качестве параметра, но каждый из которых требует для проверки своего поднабора свойств.
//Это был также мой случай, и ниже вы можете найти несколько шагов, чтобы решить его.

//1) Реализовать пользовательскую аннотацию, которая позволяет указывать группы проверки на уровне метода
//в дополнение к группам, указанным через @Validated на уровне класса.

// @Component — это общий стереотип для любого компонента или компонента, управляемого Spring.
//@Repository — это стереотип для персистентного слоя.
//@Service — это стереотип для сервисного уровня.
//@Controller — это стереотип для уровня представления (spring-MVC).                      

//Это все о разнице между @Component , @Controller , @Service и @Repository в Spring Framework . 
//Как я уже сказал, все они используются для автоматического обнаружения бинов Spring, 
//когда включено сканирование контекста, и, по сути, предоставляют 
//те же функциональные возможности в отношении внедрения зависимостей.
//
//Их единственное отличие заключается в их назначении, т.е. @Controller используется в Spring MVC
//для определения контроллера, который является сначала bean-компонентом Spring, 
//а затем контроллером. Аналогично, @Service используется для аннотированных классов,
//которые содержат бизнес-логику на уровне службы, а @Repository используется на уровне доступа к данным.

   

//@ModelAttribute
//Я обнаружил, что моя первоначальная борьба за понимание @ModelAttribute была результатом
//решения Spring объединить несколько аннотаций в один. Это стало яснее, 
//когда я разделил его на несколько небольших аннотаций:
//
//Для аннотаций параметров подумайте о @ModelAttribute как эквиваленте @Autowired + @Qualifier, 
//то есть он пытается получить bean с заданным именем из управляемой модели Spring. 
//Если названный bean не найден, вместо того, чтобы бросать ошибку или возвращать null, 
//он неявно берет на себя роль @Bean, т.е. Создайте новый экземпляр, 
//используя конструктор по умолчанию, и добавьте bean к модели.
//
//Для аннотаций метода подумайте о @ModelAttribute как эквиваленте @Bean + @Before, т.е.
//помещает bean, созданный пользовательским кодом в модели, и 
//он всегда вызывается перед методом обработки запроса.
//
//Образно, я вижу @ModelAttribute следующим образом (пожалуйста, не принимайте это буквально!!):
//
//@Bean("person")
//@Before
//public Person createPerson(){
//  return new Person();
//}
//
//@RequestMapping(...)
//public xxx handlePersonRequest( (@Autowired @Qualifier("person") | @Bean("person")) Person person, xxx){
//  ...
//}
//Как вы можете видеть, Spring принял правильное решение сделать @ModelAttribute 
//всеобъемлющую аннотацию; никто не хочет видеть аннотацию smorgasbord.
               
//@Entity                                           
//Аннотацией @Entity отмечаются классы, которые представляют собой сущности базы данных. 
//Например, если в базе данных есть таблица User, которая содержит список пользователей, 
//в Java должен существовать класс User, отмеченный аннотацией @Entity, 
//объектом этого класса будет строка таблицы User. Часто используется совместно с аннотацией @Table, 
//которая помогает явно определить некоторую информацию о таблице.
//


//Repository или CrudRepository.
//Репозитории Spring Data JPA - это интерфейсы, которые вы можете определить для доступа к данным.
//Запросы JPA создаются автоматически из имен ваших методов. Например, интерфейс CityRepository 
//может объявить метод findAllByState(String state), чтобы найти все города (city) в данном штате (state).
//
//Для более сложных запросов вы можете аннотировать ваш метод аннотацией Query в Spring Data.

//Хранилища Spring Data обычно берутся из интерфейсов Repository или CrudRepository. 
//Если вы используете автоконфигурацию, поиск в репозиториях происходит из пакета,
//содержащего ваш основной класс конфигурации (тот, который аннотирован @EnableAutoConfiguration 
//или @SpringBootApplication).

//@GeneratedValue
//Аннотация @GeneratedValue для JPA. В JPA значение примечания @GeneratedValue главным образом 
//заключается в создании уникально идентифицированного первичного ключа для объекта 
//(JPA требует, чтобы каждый объект должен иметь один и только один первичный ключ). 
//@GeneratedValue обеспечивает генерацию первичного ключа. стратегия. 
//Аннотация @GeneratedValue имеет два атрибута, а именно, стратегию и генератор, 
//где значением атрибута генератора является строка со значением по умолчанию "", 
//которое объявляет имя генератора первичного ключа (соответствует генераторам первичного ключа 
//с тем же именем @SequenceGenerator и @TableGenerator ).
//
//JPA предоставляет разработчикам четыре стратегии генерации первичных ключей, 
//которые определены в классе перечисления GenerationType, 
//включая GenerationType.TABLE, GenerationType.SEQUENCE, GenerationType.IDENTITY и GenerationType.AUTO. 

//@MappedSuperclass
//Аннотация @MappedSuperclass позволяет включать класс и его jpa аннотации в производный класс, не делая базовый класс сущностью. 
//Типичное использование в примере выше — абстрактный базовый класс, несущий в себе суррогатный первичный ключ.
//
//В базе данных всё будет выглядеть, как если бы поля базового класса были определены непосредственно в производном классе.
                

//ModelAndView
//Я всегда использую подход, в котором методы контроллера возвращаются ModelAndView. 
//Просто потому, что он, как правило, делает методы контроллера немного более краткими. 
//Параметры метода теперь строго input. И все связанные данные output содержатся в объекте, возвращаемом методом.
//
//Стиль ModelAndView, похоже, резонирует с людьми, которым не нравится обновлять входные параметры для метода. 
//Придерживаясь убеждения, что это будет представлять собой побочный эффект, опасный шаблон, потому что вы не можете надежно предсказать, 
//что будет делать этот метод, - он может возвращать данные в возвращаемом объекте, 
//или он мог бы обновить что-либо в любом из входных аргументов.
//
//Итак, некоторые люди по-прежнему предпочитают ModelAndView.
//
//
//Новый стиль с Model как параметр метода и возвращаемая строка в качестве имени представления. 
//Кажется, это исходит из немного другого подхода к дизайну. Здесь объекты модели считаются разновидностью событий или элементов, 
//которые передаются нескольким обработчикам, перед возвратом в представление, где они отображаются.
//Это напоминает мне, как события обрабатываются в мире AWT/Swing. Эта модель более согласована с подходом,
//в котором несколько обработчиков могут строиться поверх объектов Model, пока не достигнут вид.
//
//Таким образом, в конце дня, похоже, нет определенной причины критиковать или продвигать любой подход.
//Вы должны использовать стиль, который будет более соответствовать вашей общей философии дизайна.                  
                              
   

//@RequestMapping
//Аннотация @RequestMapping предназначена для того, чтобы задать методам вашего контроллера адреса, 
//по которым они будут доступны на клиенте. Есть два основных применения этой аннотации:
//
//Для всего класса контроллера
//Для отдельного метода
//
//Применение аннотации ко всему классу задаёт "каталог", в котором будут размещаться методы контроллера. Например,
//
//@Controller
//@RequestMapping("/my/special/path")
//public class SomeController {
//  //...
//}
//Здесь все методы контроллера будут доступны по адресам http://server/my/special/path/адрес метода.
//Применение аннотации к отдельному методу может выглядеть так:
//
//@Controller
//@RequestMapping("/my/special/path")
//public class SomeController {
//  @RequestMapping("/somedata")
//  public String loadSomeData() {
//    //---
//  }
//}
//Соответственно, этот метод будет срабатывать по адресу http://server/my/special/path/somedata.
 

//@ControllerAdvice
//Среди многих новых функций в Spring 4 я обнаружил улучшения @ControllerAdvice. 
//@ControllerAdvice – это специализация @Component, которая используется для определения методов @ExceptionHandler, 
//@InitBinder и @ModelAttribute, которые применяются ко всем методам @RequestMapping. 
//До весны 4 @ControllerAdvice помогал всем контроллерам в одном и том же сервлете диспетчера. 
//С весны 4 все изменилось. Начиная с Spring 4 @ControllerAdvice может быть настроен для поддержки определенного подмножества контроллеров, 
//тогда как поведение по умолчанию все еще может использоваться.   

//@ExceptionHandler
               
//Ваш вопрос довольно сбивает с толку, но ваш метод обработчика исключений будет обрабатывать только одно исключение за раз. 
//Он не будет перехватывать несколько исключений, а затем передавать их оба в ваш метод handleFormException (). 
//Если вам нужно обрабатывать эти типы исключений по-разному, 
//вы должны создать метод обработчика исключений для каждого из них, 
//указать аргумент этого конкретного типа исключения для вашего метода, 
//а затем выполнить соответствующую обработку. Например:
//
//@ExceptionHandler(DescriptionCstOrderException.class)
//public String handleDescriptionCstOrderException(DescriptionCstOrderException exception, ActionRequest actionRequest) {...}
//
//
//@ExceptionHandler(SpecializationCstOrderException.class)
//public String handleSpecializationCstOrderException(SpecializationCstOrderException exception, ActionRequest actionRequest) {...}
//                     
   
//@JsonDeserialize 
//используется для указания настраиваемого десериализатора для демонтажа объекта json.     
        

//@Service
//Помимо предоставления аннотаций @Component, Spring 2.5 также определяет несколько аннотаций со специальной семантикой:
//@Repository, @Service и @Controller.
//В текущей версии Spring эти три аннотации эквивалентны @Component, но из именования класса аннотаций легко увидеть, 
//что эти три аннотации связаны с постоянным уровнем, бизнес-уровнем и уровнем управления (веб-уровень). соответствовать.
//Хотя эти три аннотации не новы по сравнению с @Component, Spring добавит к ним специальные функции в будущих версиях.
//Поэтому, если веб-приложение принимает классическую трехуровневую иерархическую структуру, 
//лучше всего использовать вышеупомянутые аннотации для аннотирования классов на уровне на уровне постоянства, бизнес-уровне и уровне управления.
//
//@Service используется для маркировки компонентов бизнес-уровня
//
//@Controller используется для аннотирования компонентов слоя управления (например, действий в структурах)
//
//@Repository используется для аннотирования компонентов доступа к данным, а именно компонентов DAO
//
//@Component относится к компоненту в целом. Когда компонент не классифицирован,
//мы можем использовать эту аннотацию, чтобы отметить его.


//@SpringBootTest
//Spring Boot предоставляет аннотацию @SpringBootTest, которую можно использовать в качестве альтернативы 
//стандартной аннотации spring-test @ContextConfiguration, когда вам нужны функции Spring Boot. 
//Аннотация работает, создавая ApplicationContext, используемый в ваших тестах, через SpringApplication. 
//В дополнение к @SpringBootTest также предусмотрен ряд других аннотаций для тестирования более специфических фрагментов приложения.
//
//Если вы используете JUnit 4, не забудьте также добавить @RunWith(SpringRunner.class) в ваш тест, 
//иначе аннотации будут проигнорированы. Если вы используете JUnit 5, нет необходимости добавлять 
//эквивалент @ExtendWith(SpringExtension.class) в качестве @SpringBootTest, а остальные @… аннотации теста уже аннотированы с ним.
//
//По умолчанию @SpringBootTest не запускает сервер. Вы можете использовать атрибут webEnvironment @SpringBootTest 
//для дальнейшего уточнения того, как выполняются ваши тесты:
//
//MOCK (по умолчанию): загружает веб ApplicationContext и предоставляет фиктивную веб-среду. 
//Встроенные серверы не запускаются при использовании этой аннотации. Если веб-среда недоступна на вашем пути к классам, 
//этот режим прозрачно возвращается к созданию обычного не веб ApplicationContext. 
//Его можно использовать вместе с @AutoConfigureMockMvc или @AutoConfigureWebTestClient для тестового тестирования вашего веб-приложения.
//RANDOM_PORT: загружает WebServerApplicationContext и предоставляет реальную веб-среду. 
//Встроенные серверы запускаются и прослушивают случайный порт.   
//DEFINED_PORT: загружает WebServerApplicationContext и предоставляет реальную веб-среду. 
//Встроенные серверы запускаются и прослушивают определенный порт (из вашего application.properties) или порт 8080 по умолчанию.
//NONE: загружает ApplicationContext с помощью SpringApplication, но не предоставляет какой-либо веб-среды (фиктивной или иной).
//Если ваш тест является @Transactional, он по умолчанию откатывает транзакцию в конце каждого метода тестирования. 
//Однако, поскольку использование этого соглашения с RANDOM_PORT или DEFINED_PORT неявно обеспечивает реальную среду сервлета, 
//HTTP-клиент и сервер работают в отдельных потоках и, таким образом, в отдельных транзакциях. 
//Любая транзакция, инициированная на сервере, в этом случае не откатывается.
//
//@SpringBootTest с webEnvironment = WebEnvironment.RANDOM_PORT также запустит сервер управления на отдельном случайном порте,
//если ваше приложение использует другой порт для сервера управления.
//
//
      

//@Autowired
//Используя эту аннотацию, не нужно заботиться о том, как лучше всего передать классу или bean'у экземпляр другого bean'a.
//Фреймворк Spring сам найдет нужный bean и подставит его значение в свойство, которое отмечено аннотацией @Autowired.
//
//@Autowired и свойство класса
//Свойства класса с аннотацией @Autowired заполняются соответствующими значениями сразу после создания bean'а и перед тем,
//как любой из методов класса будет вызван. Пример:
//
//
//    @Autowired
//    private FieldService propertyService;
//                                 

//	@WebMvcTest
//	Опять же, очень похоже на @DataJpaTest и @DataMongoTest , для выполнения классических тестов Spring MVC мы применяем
//	@WebMvcTest вместе с аннотацией @RunWith(SpringRunner.class) .
//
//	Имейте в виду, что эффекты этой аннотации применимы только к инфраструктуре MVC. При этом он не создает экземпляр всего контекста.
//
//	Аннотацию можно использовать для тестирования одного контроллера, передав его как атрибут, например @WebMvcTest(SomeController.class) .
//
//	Чтобы создать экземпляры других необходимых зависимостей, таких как службы, мы обычно используем аннотацию 
//	@MockBean @WebMvcTest настраивает MockMvc который можно использовать для простого и быстрого тестирования
//	контроллеров MVC и создания экземпляров других участников:
//
//	 @RunWith(SpringRunner.class) 
//	 @WebMvcTest(HomeController.class) 
//	 public class ControllerTests { 
//	 
//	 // Auto-configured to make mocking easier 
//	 @Autowired 
//	 private MockMvc mockMvc; 
//	 
//	 @MockBean 
//	 private SomeBean someBean; 
//	 
//	 @Test 
//	 public void someTest() { 
//	 // Test logic 
//	 } 
//	 } 	                   
//            
	
	
//	@MockBean
//	При тестировании конкретных модулей, например, контроллера, мы хотим максимально изолировать их. 
//	Поскольку большинство компонентов Spring Application зависят от множества других компонентов (зависимостей), 
//	квинтэссенцией является обеспечение возможности индивидуального тестирования всех этих компонентов.
//
//	Для того, чтобы успешно изолировать объекты мы хотим проверить, в то же время позволяя приложению работать нормально, 
//	мы издеваться или имитировать зависимости. @MockBean аннотаций используется , когда мы хотим , 
//	чтобы дразнить зависимость в приложении:
//
//	 @RunWith(SpringRunner.class) 
//	 @WebMvcTest(HomeController.class) 
//	 public class ControllerTests { 
//	 
//	 // Auto-configured to make mocking easier 
//	 @Autowired 
//	 private MockMvc mockMvc; 
//	 
//	 @MockBean 
//	 private SomeBean someBean; 
//	 
//	 @Test 
//	 public void someTest() { 
//	 // Test logic 
//	 } 
//	 } 
//	В этом примере someBean реальную зависимость. Если компонент существует в контексте, макет заменяет его. 
//	Если его не существует, макет добавляется в контекст как bean-компонент.
//
//	Примечание . Между аннотациями @Mock и @MockBean @Mock взята из библиотеки Mockito и эквивалентна вызову Mockito.mock() . 
//	С другой стороны, @MockBean - это оболочка библиотеки Spring для аннотации @Mock
//                 
//                       
                          
//	Аннотации Mockito @InjectMocks позволяют нам вводить издевательские зависимости в аннотированный объект издевательства над классом. 
//	Это полезно, когда у нас есть внешние зависимости в классе, над которым мы хотим издеваться.
//	Мы можем указать фиктивные объекты, которые будут введены, используя аннотации @Mock или @Spy.
//
//	Mockito @InjectMocks
//	Mockito пытается внедрить издевательские зависимости, используя один из трех подходов, в указанном порядке.
//
//	Инъекция на основе конструктора – когда для класса определен конструктор, Mockito пытается внедрить зависимости, 
//	используя самый большой конструктор.
//	На основе методов настройки – когда не определены конструкторы, 
//	Mockito пытается внедрить зависимости с помощью методов настройки.
//	На основе полей – если нет конструкторов или возможной инъекции на основе полей, 
//	то mockito пытается внедрить зависимости в само поле.
//	Если есть только один соответствующий макет объекта, то mockito введет его в объект. 
//	Если существует более одного поддельного объекта одного и того же класса, то имя поддельного объекта используется для введения зависимостей.              
//                      
                                                      
                                                                                                                                                                                                                                                                
	                                                                                    
	 
}
